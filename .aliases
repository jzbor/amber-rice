#!/bin/bash
# Adding my own aliases

alias :q="exit"
alias fucking="sudo"
alias icat="swallow sxiv"
alias kcc=kdeconnect-cli
alias la="ls -a"
alias ls='ls -hN --color=auto --group-directories-first'
alias lsla="ls -la"
alias mkdir="mkdir -pv"
alias mpg123="mpg123 --verbose"
alias nmc="nmtui-connect"
alias notes="notes.sh"
alias pacupdate="sudo pacman -Syu"
alias ping="ping -c 5"
alias please="sudo"
alias saidar="saidar -c"
alias todo="$EDITOR ~/Documents/Notes/todo.md"
alias v="nvim"
alias vim="nvim"
alias vimdiff="nvim -d"

alias nvim-profile="vim --cmd 'profile start profile.log' \
    --cmd 'profile func *' \
    --cmd 'profile file *' \
    -c 'profdel func *' \
    -c 'profdel file *' \
    -c 'qa!'
"

nmap-local () {
    addresses="$(ip addr | grep "inet " | grep -v "127.0.0.1" | awk '{ print $2 }' | paste -s -d' ')"
    echo nmap $addresses "$@"
    nmap $addresses "$@"
}

share-local () {
    echo "Python webserver for $(pwd) on http://$(ip addr | grep "inet " | grep -v "127.0.0.1" | awk '{ print $2 }' | sed 's/\/.*//'):8000/"
    echo
    python -m http.server
}

artix-docs () {
    doc_file="$(ls /usr/share/doc/artix | fzf)"
    [ -n "$doc_file" ] && zathura "/usr/share/doc/artix/$doc_file"
}

# Configs
alias cfa='$EDITOR $HOME/.aliases'
alias cfb='$EDITOR $HOME/.config/bspwm/bspwmrc'
alias cfd='cd Programming/C/dwm'
alias cfh='$EDITOR $HOME/.config/sxhkd/sxhkdrc'
alias cfi='$EDITOR $HOME/.config/i3/config'
alias cfk='$EDITOR $HOME/.config/kitty/kitty.conf'
alias cfpm='$EDITOR $HOME/.config/polybar/modules'
alias cfq='$EDITOR $HOME/.aliases'
alias cfs='$EDITOR $HOME/.bashrc'
alias cfv='$EDITOR $HOME/.vimrc'
alias cfx='$EDITOR $HOME/.Xresources'
alias cfz='$EDITOR $ZDOTDIR/.zshrc'

alias config='/usr/bin/git --git-dir=$HOME/.dotfiles/ --work-tree=$HOME'
alias config-pull='/usr/bin/git --git-dir=$HOME/.dotfiles/ --work-tree=$HOME fetch origin master; \
    /usr/bin/git --git-dir=$HOME/.dotfiles/ --work-tree=$HOME reset --hard origin/master'

# FZF bindings
vf () {
    if [ $# -eq 0 ]; then
        file="$(fzf --height 50%)"
    else
        file="$(fzf --query "$@" --height 50%)"
    fi
    [ -n "$file" ] && nvim "$file"
}
cdf () {
    if [ $# -eq 0 ]; then
        file="$(fzf --height 50%)"
    else
        file="$(fzf --query "$@" --height 50%)"
    fi
    [ -n "$file" ] && cd "$(dirname $file)"
}
cfg () {
    if [ $# -eq 0 ]; then
        file="$HOME/$(config ls-files --full-name ~ | fzf --height 50%)"
    else
        file="$HOME/$(config ls-files --full-name ~ | fzf --query "$@" --height 50%)"
    fi
    [ -f "$file" ] && nvim "$file"
}
browse () {
    selection="$(printf "..\n%s" "$(ls -t)" | fzf)"
    if [ "$selection" = "" ]; then
        return
    else
        cd "$selection" || (xdg-open "$selection"; exit)
        browse
    fi
}
ff () {
    browse
    printf "\n%s:\n" "$(pwd)"
    ls
    echo
}
project () {
    cd "$(ls -d -t ~/Programming/*/* | \
        sed "s/$(echo $HOME | sed 's/\//\\\//g')/~/" | \
        fzf --height 50% | \
        sed "s/~/$(echo $HOME | sed 's/\//\\\//g')/")"
}

# Templates
export TEMPLATES="$HOME/Templates"
alias ta='cp $TEMPLATES/article.tex'
alias tb='cp $TEMPLATES/beamer.tex'
alias tp='cp $TEMPLATES/python.py'
alias ts='cp $TEMPLATES/shell-script.sh'
t () {
    if [ "$#" = 0 ]; then
	printf "Available templates (from $TEMPLATES):\n\n"
	tree "$TEMPLATES"
    elif [ -e "$2" ]; then
	echo "File $2 already exists."
    elif (ls "$TEMPLATES" -1 | grep "$1" > /dev/null); then
	cp -r "$TEMPLATES/$1" "$2"
	echo "Created $2 from template $1."
    else
	echo "Template $1 not found."
    fi
}

#
# # ex - archive extractor
# # usage: ex <file>
ex ()
{
  if [ -f $1 ] ; then
    case $1 in
      *.tar.bz2)   tar xvjf $1   ;;
      *.tar.gz)    tar xvzf $1   ;;
      *.tar.xz)    tar xvf $1   ;;
      *.bz2)       bunzip2 $1   ;;
      *.rar)       unrar x $1     ;;
      *.gz)        gunzip $1    ;;
      *.tar)       tar xf $1    ;;
      *.tbz2)      tar xjf $1   ;;
      *.tgz)       tar xzf $1   ;;
      *.zip)       unzip $1     ;;
      *.Z)         uncompress $1;;
      *.7z)        7z x $1      ;;
      *)           echo "'$1' cannot be extracted via ex()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}


cd () {
    gitdir="$(git rev-parse --show-toplevel 2> /dev/null)"
    if [ "$#" -gt 0 ]; then
	command cd "$@"
    elif [ "$gitdir" = "$(pwd)" ]; then
	command cd "$HOME"
    elif [ "$gitdir" = "" ]; then
	command cd "$HOME"
    else
	command cd "$gitdir"
    fi
}


# Youtube-dl
yt_format="(137/bestvideo[ext=mp4])+bestaudio/best[ext=mp4]/best"
alias yt="youtube-dl --add-metadata --restrict-filenames -f '$yt_format' -ic" # Download link
alias yta="youtube-dl --add-metadata --restrict-filenames -f '$yt_format' -ic" # Download audio only
alias ytl="youtube-dl --add-metadata --restrict-filenames -f '$yt_format' -ic -a" # Download list from file

# Audio player
# Source:https://unix.stackexchange.com/questions/132230/read-out-pulseaudio-volume-from-commandline-i-want-pactl-get-sink-volume#164740
getdefaultsinkname() {
    pacmd stat | awk -F": " '/^Default sink name: /{print $2}'
}
getdefaultsinkvol() {
    pacmd list-sinks |
        awk '/^\s+name: /{indefault = $2 == "<'$(getdefaultsinkname)'>"}
            /^\s+volume: / && indefault {print $5; exit}' |
        awk -F"%" '{print $1}'
}
pv () {
    tempvol=$(getdefaultsinkvol)
    if (( $# > 0 )); then
    	pactl set-sink-volume "$(pactl info | grep 'Default Sink' | sed 's/.*: //')" "$1%"
    	echo "$tempvol% => $(getdefaultsinkvol)%"
    else
	echo "$tempvol%"
    fi
}

music () {
    if [ "$1" = "next" ] || [ "$1" = "prev" ]; then
	# In this cases the output will probably not be up to date
	music.sh $1 > /dev/null
    else
	music.sh $1
    fi
}

alias p+='pactl set-sink-volume "$(pactl info | grep "Default Sink" | sed "s/.*: //")" +5%'
alias p-='pactl set-sink-volume "$(pactl info | grep "Default Sink" | sed "s/.*: //")" -5%'
alias pu="music prev"
alias pi="music play-pause"
alias po="music next"
alias pp="music"


# Mounting drives
alias mounted="cd /run/media/$USER && ls"

mnt () {
    lsblk -pln -o SIZE,LABEL,NAME
    print "\nPlease select a device: "
    read device
    echo
    udisksctl mount --block-device "$device" 2>&2
}

umnt () {
    lsblk -pln -o SIZE,LABEL,NAME
    print "\nPlease select a device: "
    read device
    echo
    udisksctl unmount --block-device "$device" 2>&2
}
